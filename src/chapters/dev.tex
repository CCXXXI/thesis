%! suppress = UnresolvedReference


\chapter{\app 的开发}\label{ch:dev}


\section{项目的开发环境与开发工具}\label{sec:env}

本项目包含了多种语言的代码的编写，不同语言所使用的开发环境与工具有重叠部分也有不同部分，并且在本地环境与持续集成环境中的配置也有一定差异。

\subsection{通用的环境与工具}\label{subsec:common-env}

项目中的所有代码都使用了Git进行版本控制，项目的源代码托管在GitHub上，并且使用了GitHub Actions作为持续集成工具，开发过程中也遵循了GitHub推荐并支持的pull request、release等工作流程。Git的提交信息遵循约定式提交（Conventional Commits）规范，版本号则按照语义化版本（Semantic Versioning）规范进行管理。新版本的发布及版本号的更新基于Google的Release Please工具半自动地进行，该工具同时用于更新日志的自动生成。为了方便使用GitHub，在本地安装并使用了GitHub CLI与GitHub Desktop。

项目的各部分代码均使用Codecov进行测试覆盖率的统计追踪，使用Renovate进行依赖项的自动更新，使用Restyled自动格式化代码，使用CodeFactor进行代码质量的检查，并使用Sentry来自动收集并上报错误信息。另外，各部分代码的编写都借助了GitHub Copilot来提供更智能的代码补全。

\subsection{Dart及Flutter的环境与工具}\label{subsec:dart-env}

项目开发基于最新的稳定版的Flutter SDK，在开发过程中其版本进行过几次更新，截止本文撰写时使用的是Flutter 3.7.10。Dart SDK使用的是捆绑于Flutter SDK中的对应版本，并未单独配置。

开发过程中，在本地使用了IntelliJ IDEA作为Flutter开发的IDE，安装了Flutter插件与Dart插件来提供相应的支持，并额外安装了Flutter Freezed Snippets、Flutter Intl等插件来提供更多相关功能。为了获得对移动平台开发的支持，在一台Windows设备和一台macOS设备上分别额外安装了Android Studio和Xcode及其对应移动平台设备的模拟器。

在持续集成环境中，基于subosito开发的flutter-action配置了Android和iOS平台的应用安装包的自动构建发布。除Flutter SDK自带的静态分析、代码测试等工具外，额外使用了社区开发的Dependency Validator包来检查依赖项是否有缺少或冗余。

\subsection{\LaTeX 的环境与工具}\label{subsec:latex-env}

在本地安装了\TeX\ Live 2023，并使用安装了\TeX iFy插件的IntelliJ IDEA作为IDE。在持续集成环境中，使用了xu-cheng提供的最新版\TeX\ Live的Docker镜像进行文档的编译，并配置了相应的自动发布。

\subsection{C++的环境与工具}\label{subsec:cpp-env}

项目中对于Pan-Tompkins算法和基于LibTorch的算法的开发使用了不同的环境。由于开发时主要使用的是Windows系统，所以在Pan-Tompkins算法的开发过程中使用了MSVC工具链。而基于LibTorch的算法则因为Windows平台的LibTorch分发版区分了调试与发布版本而较难使用，所以使用了安装在WSL2中的GCC工具链。两者都使用CLion作为IDE，一个直接安装在Windows系统中，另一个安装在WSL2中然后通过JetBrains Gateway连接。

在持续集成环境中，使用aminya提供的setup-cpp工具来安装必要的依赖。两个仓库中的代码均在最新的Ubuntu环境下使用GCC与CMake工具链进行编译，然后基于Gcovr进行代码覆盖率的统计。

\subsection{Python的环境与工具}\label{subsec:python-env}

对于Python环境的管理使用了Mamba，Conda的一个更优秀的替代工具。在本地安装了Mambaforge用于依赖管理，持续集成环境中则使用provision-with-micromamba工具。Python代码的测试与覆盖率生成基于pytest和pytest-cov工具。本地开发的IDE选择了PyCharm。


\section{Pan-Tompkins算法的实现}\label{sec:pan-tompkins}

本应用为用户提供了实时的心率显示。因为所使用的基于LibTorch的算法无法实时给出心电分割结果，所以有必要另外使用一种实时在线算法来进行心率的统计。

Pan-Tompkins算法\cite{panRealTimeQRSDetection1985}可以用于检测心电图中的QRS波群。一次正常的窦性心律的组成如图~\ref{fig:sinus-rhythm} 所示，其中的QRS波群位于心电图中最明显的尖峰处。此功能使得Pan-Tompkins算法非常适合用作心率测量。

\begin{figure}[ht]
    \centering
    \includegraphics[width=.75\textwidth]{../assets/SinusRhythmLabels}
    \bicaption{正常窦性心律的心电图}{ECG of a heart in normal sinus rhythm}
    \label{fig:sinus-rhythm}
\end{figure}

该算法是心电分析中最经典的算法之一。于1985年被提出后，有许多人对其进行了各种各样的改进。由于算法的原始版本已经有很高的准确率（原作者给出的统计结果为99.3\%），同时本应用仅将其用作心率检测，没有很高的准确率要求，所以出于实现较为简单的优势而直接使用了原始版本的算法，而非其他人的改版。

由于Pan-Tompkins算法的应用非常广泛，多年以来，已经有大量开发者用各种语言各种方式对其进行了实现。为了不进行无意义的额外工作，本项目在Pan-Tompkins算法的实现过程中并非从零开始编写，而是基于已有的实现进行了修改。经过检索对比，发现rafaelmmoreira为该算法编写的C语言实现\footnote{\url{https://github.com/rafaelmmoreira/PanTompkinsQRS}}的代码质量较高，以MIT协议开源，并提供了充分的注释文档以方便理解，因此本项目以该版本实现为基础按项目需要进行了一些修改。

首先，将该实现由C语言迁移至了C++。除了将在C++中无法通过编译的特性（比如动态数组大小）进行了修改外，还将一些内容的写法改为了C++中惯用的写法，包括将使用宏定义的常量改为 |constexpr|、将 |fopen| 相关的写法替换为 |std::ifstream| 等。

之后，对该实现的输入输出方式进行了修改。在原始版本的算法中，程序开始运行时会打开两个文件作为输入输出。为了方便Dart调用，需要将输入输出方式改为直接通过参数和返回值进行。原作者已经考虑到需要修改输入输出方式的需求，并从算法中提取出了 |dataType input()| 和 |void output(int out)| 两个函数。原始情况下，算法会在需要读入新数据时调用 |input|，在分析结果就绪后调用 |output|，两者之间并不同步，而是使用了异步回调。跨语言实现异步回调虽然并非完全不可行，但相比简单的调用后直接返回的流程更为繁琐，且没有太大收益。经过分析，发现该算法实现的主体部分是一个无限循环，在循环的开头会调用 |input| 获取采样点数据，在循环中间的多处会调用 |output| 后进入到下一次循环。为了将其改为单次调用后直接返回的方式，将该循环的内容提取为了另一个函数，并将需要在循环之间保留的状态由函数内的局部变量暂时改为了全局变量。同时，将输入与输出进行同步，以略微降低算法精度为代价获得了更及时的检测结果。

在该实现的原始版本中，采样率是以常量的形式硬编码在算法之中的。但是，实际调用该算法进行分析时，可能会以不同采样率的数据进行输入。一种可能的方式是将算法复制多份修改常量后分别编译，但比较繁琐。另一种方式是将该常量改为算法的参数，从外部传入。由于算法中有很多常量和变量的值与采样率有关，因此为了方便将其作为参数，将上一个步骤中提取出的全局变量与函数封装成为了类，并将采样率作为该类的构造函数的参数。这一改动也解释了之前为什么选择将C语言的实现迁移至C++而非直接使用C语言进行重构，这样可以利用C++的强大特性来简化代码的编写难度。

在最终版本的算法中，对外提供了两个函数作为接口，分别是 |void init(int fs)| 和 |bool panTompkins(float sample)|。包含相关状态与方法的类被简单地命名为 |PanTompkins|。程序中维护了一个 |std::optional<PanTompkins>| 类型的全局变量，用于存储算法的状态。在调用 |init| 时，如果全局变量目前为空或者存储的算法的采样率与传入的参数不同，则会创建一个新的算法实例并存储在全局变量中；如果全局变量目前不为空且存储的算法的采样率与传入的参数相同，则不会创建新的算法实例，而是直接复用旧的实例，以减少不必要的开销。由于用户通常不会频繁更换使用不同采样率的设备，此优化的效果是比较明显的。在调用 |panTompkins| 时，会断言当前全局变量不为空，也就是要求调用者必须先调用过 |init| 再调用此方法；之后，会将传入的采样点数据转发至算法实例的对应方法，该方法会返回一个布尔值，表示是否检测到了新的QRS波群。

在算法的测试过程中，发现其偶尔会对于同一个心拍输出两次或更多相近甚至相邻的 |true|，导致计算出的心率可能会突然提升至每分钟上千次。由于难以确定是在算法的哪一处出现了问题，所以在算法之外对于其输出结果设计了两层额外修正，而没有修改算法内部的执行逻辑。第一层修正是为算法输出的QRS波群设置最小间隔，该间隔的计算方式如下：

\[
    leastSamplesBetweenQrs = \frac{60}{maxHeartRate} \times fs
\]

其中，\(leastSamplesBetweenQrs\) 表示连续两个QRS波群之间至少需要间隔的采样点数。当算法返回了 |true| 时，会将当前的采样点与上一次检测到QRS波群的采样点进行比较，如果两者之间的采样点数目小于 \(leastSamplesBetweenQrs\)，则会忽略该检测结果，否则会将当前的采样点作为最后一次检测到QRS波群的采样点。60表示一分钟的秒数，\(maxHeartRate\) 表示最大心率（单位bpm），\(fs\) 表示采样率（单位Hz）。关于人类的心率上限，最流行的说法是220减去年龄。考虑到患者应该不会在心率超出此上限的情况下还有使用本应用观察自己心率的需求，同时为了不需要获取患者的实际年龄就可以运行算法，在实现中将\(maxHeartRate\) 设置为了常量220。经过测试，该修正可以有效地解决算法输出的QRS波群之间间隔过小导致心率上千的问题。

此外，在最终的心率显示部分也增加了一层修正。该层修正是在前述过滤方式未能完全排除算法的错误输出的情况下的缓冲。考虑到人类的心率的变化应该是相当平滑的，不太可能在相邻几个心拍之间产生非常大的变动，应用在最终将心率计算结果展示给用户的时候会先与之前的结果进行比较，如果相差超过10bpm，则会将显示结果改为上一次结果加上或减去10bpm（取决于心率是突然上升还是突然下降），但不改变底层数据的实际值。通过这种方式，可以有效地避免因为算法的错误输出导致心率突然上升或下降的情况，同时在心率真的在短时间内发生了较大的变化时，也能够在数次心拍后将心率恢复到正确的值。

应用对于心率的计算是根据最后两次检测到的心拍的间隔时间，所以另一个考虑过的修正方案是使用较多心拍之间间隔的平均值来计算心率。这种方案的效果与原理和上一段说明的方式类似，都是对心率变化进行平滑处理，滤去突变。相比起来，这种方案需要将过去的更多心拍纳入计算，但相比之前的方法在效果上没有明显的优势，所以在实现中没有采用。

\section{智能检测算法的移植与优化}\label{sec:ai}

\todo{智能检测算法的移植与优化}


\section{实时心电模块的实现}\label{sec:real-time}

\todo{实时心电模块的实现}


\section{历史心电模块的实现}\label{sec:history}

\todo{历史心电模块的实现}


\section{分析报告模块的实现}\label{sec:analytics}

\todo{分析报告模块的实现}


\section{设备管理模块的实现}\label{sec:device}

\todo{设备管理模块的实现}


\section{应用设置模块的实现}\label{sec:settings}

\todo{应用设置模块的实现}


\section{其他功能的实现}\label{sec:other}

\subsection{路由功能的实现}\label{subsec:router}

\todo{路由功能的实现}

\subsection{本地化功能的实现}\label{subsec:l10n}

\todo{本地化功能的实现}

\subsection{开发者工具的实现}\label{subsec:dev-tools}

\todo{开发者工具的实现}

\subsection{应用信息显示功能的实现}\label{subsec:about}

\todo{应用信息显示功能的实现}
